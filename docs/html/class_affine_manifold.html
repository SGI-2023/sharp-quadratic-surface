<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quadratic Contours: AffineManifold Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Quadratic Contours
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_affine_manifold-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AffineManifold Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="affine__manifold_8h_source.html">affine_manifold.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AffineManifold:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_affine_manifold.png" usemap="#AffineManifold_map" alt=""/>
  <map id="AffineManifold_map" name="AffineManifold_map">
<area href="class_parametric_affine_manifold.html" alt="ParametricAffineManifold" shape="rect" coords="0,56,156,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad8abe780d90678e99a44229f4afc8623"><td class="memItemLeft" align="right" valign="top"><a id="ad8abe780d90678e99a44229f4afc8623" name="ad8abe780d90678e99a44229f4afc8623"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="separator:ad8abe780d90678e99a44229f4afc8623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcc040d0f3ed7cda428c966c4c9b2b0d"><td class="memItemLeft" align="right" valign="top"><a id="afcc040d0f3ed7cda428c966c4c9b2b0d" name="afcc040d0f3ed7cda428c966c4c9b2b0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AffineManifold</b> ()</td></tr>
<tr class="memdesc:afcc040d0f3ed7cda428c966c4c9b2b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for a trivial manifold. <br /></td></tr>
<tr class="separator:afcc040d0f3ed7cda428c966c4c9b2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd024b85a5f3843f7e8c2552ffd2542b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#abd024b85a5f3843f7e8c2552ffd2542b">AffineManifold</a> (const Eigen::MatrixXi &amp;F, const MatrixXr &amp;global_uv, const Eigen::MatrixXi &amp;F_uv)</td></tr>
<tr class="separator:abd024b85a5f3843f7e8c2552ffd2542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5a24a432a95df21beddec821e39b16"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#ade5a24a432a95df21beddec821e39b16">num_faces</a> () const</td></tr>
<tr class="separator:ade5a24a432a95df21beddec821e39b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c91854336d95c217e3316b24dc3c6a8"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a1c91854336d95c217e3316b24dc3c6a8">num_vertices</a> () const</td></tr>
<tr class="separator:a1c91854336d95c217e3316b24dc3c6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3caa36616a55fec146dd2a6a245301"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a6e3caa36616a55fec146dd2a6a245301">get_faces</a> () const</td></tr>
<tr class="separator:a6e3caa36616a55fec146dd2a6a245301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da611ea8a9c4c82347e403c8c889f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halfedge.html">Halfedge</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a4da611ea8a9c4c82347e403c8c889f1f">get_halfedge</a> () const</td></tr>
<tr class="separator:a4da611ea8a9c4c82347e403c8c889f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e36285e30374755c46dee3611b43b15"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; Eigen::Index, Eigen::Index &gt; &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a4e36285e30374755c46dee3611b43b15">get_he_to_corner</a> () const</td></tr>
<tr class="separator:a4e36285e30374755c46dee3611b43b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc633c3366f190094bf1c07f92910650"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#acc633c3366f190094bf1c07f92910650">get_F_uv</a> () const</td></tr>
<tr class="separator:acc633c3366f190094bf1c07f92910650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634cb38fb80495675c392abbd82f27c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vertex_manifold_chart.html">VertexManifoldChart</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a634cb38fb80495675c392abbd82f27c7">get_vertex_chart</a> (Index vertex_index) const</td></tr>
<tr class="separator:a634cb38fb80495675c392abbd82f27c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68eb1ee1d21fa8bb47daaba467d22c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge_manifold_chart.html">EdgeManifoldChart</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#af68eb1ee1d21fa8bb47daaba467d22c6">get_edge_chart</a> (Index face_index, Index face_vertex_index) const</td></tr>
<tr class="separator:af68eb1ee1d21fa8bb47daaba467d22c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0287f9ba0f2ba7e9936ba740ccc579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_face_manifold_chart.html">FaceManifoldChart</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a8a0287f9ba0f2ba7e9936ba740ccc579">get_face_chart</a> (Index face_index) const</td></tr>
<tr class="separator:a8a0287f9ba0f2ba7e9936ba740ccc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7087fa8c1768c2b4327b93505f0e33b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a7087fa8c1768c2b4327b93505f0e33b8">get_face_corner_charts</a> (Index face_index, std::array&lt; Matrix2x2r, 3 &gt; &amp;corner_uv_positions) const</td></tr>
<tr class="separator:a7087fa8c1768c2b4327b93505f0e33b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a1a1db94bbed7312fd2b6cfe07027b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a61a1a1db94bbed7312fd2b6cfe07027b">get_face_edge_charts</a> (Index face_index, std::array&lt; Matrix3x2r, 3 &gt; &amp;face_edge_uv_positions) const</td></tr>
<tr class="separator:a61a1a1db94bbed7312fd2b6cfe07027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fbd7b9050cf20a8c5c78e2e87f94b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a179fbd7b9050cf20a8c5c78e2e87f94b">get_face_global_uv</a> (Index face_index, std::array&lt; PlanarPoint, 3 &gt; &amp;face_uv_positions) const</td></tr>
<tr class="memdesc:a179fbd7b9050cf20a8c5c78e2e87f94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uv coordinates of the face.  <br /></td></tr>
<tr class="separator:a179fbd7b9050cf20a8c5c78e2e87f94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2ab050df58c8d1c05a5177b508686e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#abf2ab050df58c8d1c05a5177b508686e">compute_curvature</a> (Index vertex_index) const</td></tr>
<tr class="separator:abf2ab050df58c8d1c05a5177b508686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356d226d3ecf36569fb68df02b568ace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a356d226d3ecf36569fb68df02b568ace">is_boundary</a> (Index vertex_index) const</td></tr>
<tr class="separator:a356d226d3ecf36569fb68df02b568ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad954f76d53659be3361d2c3c2e5f8adc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#ad954f76d53659be3361d2c3c2e5f8adc">is_flat</a> (Index vertex_index) const</td></tr>
<tr class="separator:ad954f76d53659be3361d2c3c2e5f8adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e940c1335c5e897474c6bd57173e730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a3e940c1335c5e897474c6bd57173e730">compute_flat_vertices</a> (std::vector&lt; Index &gt; &amp;flat_vertices)</td></tr>
<tr class="separator:a3e940c1335c5e897474c6bd57173e730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01a8524558ba2f7b8b233f5ff87e465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#ad01a8524558ba2f7b8b233f5ff87e465">compute_cones</a> (std::vector&lt; Index &gt; &amp;cones) const</td></tr>
<tr class="separator:ad01a8524558ba2f7b8b233f5ff87e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b4cadb93a95d30bc9d5b41dd6a1a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#ad4b4cadb93a95d30bc9d5b41dd6a1a36">compute_cones_corners</a> (std::vector&lt; std::array&lt; bool, 3 &gt; &gt; &amp;is_cone_corner) const</td></tr>
<tr class="separator:ad4b4cadb93a95d30bc9d5b41dd6a1a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66b5b8fa55de132b00760a35cc16c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#ad66b5b8fa55de132b00760a35cc16c79">compute_cone_points</a> (const MatrixXr &amp;V, MatrixXr &amp;cone_points) const</td></tr>
<tr class="separator:ad66b5b8fa55de132b00760a35cc16c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe8922a412d98788352cb03028b291"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a3cfe8922a412d98788352cb03028b291">generate_cones</a> () const</td></tr>
<tr class="separator:a3cfe8922a412d98788352cb03028b291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d42ebbfc83dc4296c7c54c53ea616d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a22d42ebbfc83dc4296c7c54c53ea616d">compute_boundary_vertices</a> (std::vector&lt; Index &gt; &amp;boundary_vertices) const</td></tr>
<tr class="separator:a22d42ebbfc83dc4296c7c54c53ea616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d86f39f9e64ca7fea38031e8bcadb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a429d86f39f9e64ca7fea38031e8bcadb">generate_boundary_vertices</a> () const</td></tr>
<tr class="separator:a429d86f39f9e64ca7fea38031e8bcadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a04906aca9ee8f0b89c237f992a0dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a6a04906aca9ee8f0b89c237f992a0dc3">mark_cone_adjacent_vertex</a> (Index vertex_index)</td></tr>
<tr class="memdesc:a6a04906aca9ee8f0b89c237f992a0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a vertex as adjacent to a cone.  <br /></td></tr>
<tr class="separator:a6a04906aca9ee8f0b89c237f992a0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c977f357135897e2d431714fe70fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#aeb6c977f357135897e2d431714fe70fc">mark_cone_adjacent_face</a> (Index face_index)</td></tr>
<tr class="memdesc:aeb6c977f357135897e2d431714fe70fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a face as adjacent to a cone.  <br /></td></tr>
<tr class="separator:aeb6c977f357135897e2d431714fe70fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c0b0bef9631b4473650bd3bfe33950"><td class="memItemLeft" align="right" valign="top">MatrixXr const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a58c0b0bef9631b4473650bd3bfe33950">get_global_uv</a> () const</td></tr>
<tr class="separator:a58c0b0bef9631b4473650bd3bfe33950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f64c24d613162ca0b1b6a6606da4f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a89f64c24d613162ca0b1b6a6606da4f1">cut_cone_edges</a> ()</td></tr>
<tr class="separator:a89f64c24d613162ca0b1b6a6606da4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e14fba7016671a956b874969b66c99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a6e14fba7016671a956b874969b66c99e">add_to_viewer</a> (const MatrixXr &amp;V, Eigen::Matrix&lt; double, 3, 1 &gt; color=GOLD_YELLOW) const</td></tr>
<tr class="separator:a6e14fba7016671a956b874969b66c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98136d633fd83c40fe11e4e430b9f360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a98136d633fd83c40fe11e4e430b9f360">view</a> (const MatrixXr &amp;V) const</td></tr>
<tr class="separator:a98136d633fd83c40fe11e4e430b9f360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fc2437460dcbc13c5d64fc67ec2212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_affine_manifold.html#a74fc2437460dcbc13c5d64fc67ec2212">screenshot</a> (const std::string &amp;filename, const MatrixXr &amp;V, SpatialVector camera_position, SpatialVector camera_target, bool use_orthographic) const</td></tr>
<tr class="separator:a74fc2437460dcbc13c5d64fc67ec2212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01730d5d158dfe6974a695362b2a239e"><td class="memItemLeft" align="right" valign="top"><a id="a01730d5d158dfe6974a695362b2a239e" name="a01730d5d158dfe6974a695362b2a239e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a01730d5d158dfe6974a695362b2a239e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b20c8f05ea8f4ffd552257089acf536"><td class="memItemLeft" align="right" valign="top"><a id="a5b20c8f05ea8f4ffd552257089acf536" name="a5b20c8f05ea8f4ffd552257089acf536"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_vertex_charts_from_lengths</b> (const Eigen::MatrixXi &amp;F, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;l, std::vector&lt; <a class="el" href="struct_vertex_manifold_chart.html">VertexManifoldChart</a> &gt; &amp;vertex_charts) const</td></tr>
<tr class="separator:a5b20c8f05ea8f4ffd552257089acf536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9b99ac62dacf1df5d180e8893785ac"><td class="memItemLeft" align="right" valign="top"><a id="aaf9b99ac62dacf1df5d180e8893785ac" name="aaf9b99ac62dacf1df5d180e8893785ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_edge_charts_from_lengths</b> (const Eigen::MatrixXi &amp;F, const <a class="el" href="class_halfedge.html">Halfedge</a> &amp;halfedge, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;l, std::vector&lt; <a class="el" href="struct_edge_manifold_chart.html">EdgeManifoldChart</a> &gt; &amp;edge_charts) const</td></tr>
<tr class="separator:aaf9b99ac62dacf1df5d180e8893785ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882c9f66233b115e1d4f4ba58931a48e"><td class="memItemLeft" align="right" valign="top"><a id="a882c9f66233b115e1d4f4ba58931a48e" name="a882c9f66233b115e1d4f4ba58931a48e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_face_charts</b> (const Eigen::MatrixXi &amp;F, const MatrixXr &amp;global_uv, const Eigen::MatrixXi &amp;F_uv, std::vector&lt; <a class="el" href="struct_face_manifold_chart.html">FaceManifoldChart</a> &gt; &amp;face_charts) const</td></tr>
<tr class="separator:a882c9f66233b115e1d4f4ba58931a48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311f5228ed849712a5d5b41515848b48"><td class="memItemLeft" align="right" valign="top"><a id="a311f5228ed849712a5d5b41515848b48" name="a311f5228ed849712a5d5b41515848b48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_corner_to_edge_map</b> (const std::vector&lt; std::vector&lt; Halfedge::Index &gt; &gt; &amp;corner_to_he, const std::vector&lt; Halfedge::Index &gt; &amp;he_to_edge, std::vector&lt; std::vector&lt; Halfedge::Index &gt; &gt; &amp;corner_to_edge) const</td></tr>
<tr class="separator:a311f5228ed849712a5d5b41515848b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17663c7c1e141e1252f842e0a4287e73"><td class="memItemLeft" align="right" valign="top"><a id="a17663c7c1e141e1252f842e0a4287e73" name="a17663c7c1e141e1252f842e0a4287e73"></a>
PlanarPoint&#160;</td><td class="memItemRight" valign="bottom"><b>layout_next_vertex</b> (const PlanarPoint &amp;current_point, double next_edge_length, double prev_edge_length) const</td></tr>
<tr class="separator:a17663c7c1e141e1252f842e0a4287e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eedbdd65e809ff339f2d3071dfae48"><td class="memItemLeft" align="right" valign="top"><a id="a67eedbdd65e809ff339f2d3071dfae48" name="a67eedbdd65e809ff339f2d3071dfae48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>layout_one_ring</b> (const Eigen::MatrixXi &amp;F, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;l, Index vertex_index, const std::vector&lt; Index &gt; &amp;vertex_one_ring, const std::vector&lt; Index &gt; &amp;face_one_ring, MatrixXr &amp;one_ring_uv_positions) const</td></tr>
<tr class="separator:a67eedbdd65e809ff339f2d3071dfae48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f5957464bacf0e4ec3deacb308697"><td class="memItemLeft" align="right" valign="top"><a id="a854f5957464bacf0e4ec3deacb308697" name="a854f5957464bacf0e4ec3deacb308697"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_lengths_from_global_uv</b> (const Eigen::MatrixXi &amp;F, const MatrixXr &amp;global_uv, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;l) const</td></tr>
<tr class="separator:a854f5957464bacf0e4ec3deacb308697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1eeeebb7bcc83661f2800c2e7bb7f8"><td class="memItemLeft" align="right" valign="top"><a id="a8b1eeeebb7bcc83661f2800c2e7bb7f8" name="a8b1eeeebb7bcc83661f2800c2e7bb7f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>align_local_charts</b> (const MatrixXr &amp;uv, const Eigen::MatrixXi &amp;F_uv)</td></tr>
<tr class="separator:a8b1eeeebb7bcc83661f2800c2e7bb7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10d361d2b96697d7d7345f5439a9673"><td class="memItemLeft" align="right" valign="top"><a id="ab10d361d2b96697d7d7345f5439a9673" name="ab10d361d2b96697d7d7345f5439a9673"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_cones</b> ()</td></tr>
<tr class="separator:ab10d361d2b96697d7d7345f5439a9673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb58b7536729e02aefe0ff777e4d4289"><td class="memItemLeft" align="right" valign="top"><a id="abb58b7536729e02aefe0ff777e4d4289" name="abb58b7536729e02aefe0ff777e4d4289"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_corner_uv_length</b> (Index face_index, Index face_vertex_index) const</td></tr>
<tr class="separator:abb58b7536729e02aefe0ff777e4d4289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78324faad74d9595efab9409681ecf2b"><td class="memItemLeft" align="right" valign="top"><a id="a78324faad74d9595efab9409681ecf2b" name="a78324faad74d9595efab9409681ecf2b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_affine_manifold</b> () const</td></tr>
<tr class="separator:a78324faad74d9595efab9409681ecf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a659482ada1bbb87955af0bf67a197592"><td class="memItemLeft" align="right" valign="top"><a id="a659482ada1bbb87955af0bf67a197592" name="a659482ada1bbb87955af0bf67a197592"></a>
Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><b>m_F</b></td></tr>
<tr class="separator:a659482ada1bbb87955af0bf67a197592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b96d7d36639ddfbc19549db8012d597"><td class="memItemLeft" align="right" valign="top"><a id="a9b96d7d36639ddfbc19549db8012d597" name="a9b96d7d36639ddfbc19549db8012d597"></a>
std::vector&lt; std::vector&lt; Halfedge::Index &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_corner_to_he</b></td></tr>
<tr class="separator:a9b96d7d36639ddfbc19549db8012d597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5795f8b6b7e35d4695b7950244efe2b2"><td class="memItemLeft" align="right" valign="top"><a id="a5795f8b6b7e35d4695b7950244efe2b2" name="a5795f8b6b7e35d4695b7950244efe2b2"></a>
std::vector&lt; std::vector&lt; Halfedge::Index &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_corner_to_edge</b></td></tr>
<tr class="separator:a5795f8b6b7e35d4695b7950244efe2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6da09b7d597e1790f95d8a588607f9"><td class="memItemLeft" align="right" valign="top"><a id="ada6da09b7d597e1790f95d8a588607f9" name="ada6da09b7d597e1790f95d8a588607f9"></a>
std::vector&lt; std::pair&lt; Eigen::Index, Eigen::Index &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_he_to_corner</b></td></tr>
<tr class="separator:ada6da09b7d597e1790f95d8a588607f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce32e08d9f1f16cea8e232dce5d2f43"><td class="memItemLeft" align="right" valign="top"><a id="a1ce32e08d9f1f16cea8e232dce5d2f43" name="a1ce32e08d9f1f16cea8e232dce5d2f43"></a>
<a class="el" href="class_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_halfedge</b></td></tr>
<tr class="separator:a1ce32e08d9f1f16cea8e232dce5d2f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05408b21fba105d4f246ad93c813eb0"><td class="memItemLeft" align="right" valign="top"><a id="ae05408b21fba105d4f246ad93c813eb0" name="ae05408b21fba105d4f246ad93c813eb0"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_l</b></td></tr>
<tr class="separator:ae05408b21fba105d4f246ad93c813eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac134470eec47e7f2fd9f2cd9b5e722bd"><td class="memItemLeft" align="right" valign="top"><a id="ac134470eec47e7f2fd9f2cd9b5e722bd" name="ac134470eec47e7f2fd9f2cd9b5e722bd"></a>
MatrixXr&#160;</td><td class="memItemRight" valign="bottom"><b>m_global_uv</b></td></tr>
<tr class="separator:ac134470eec47e7f2fd9f2cd9b5e722bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3cff4413459b99f86db490df4c0e8f"><td class="memItemLeft" align="right" valign="top"><a id="a7d3cff4413459b99f86db490df4c0e8f" name="a7d3cff4413459b99f86db490df4c0e8f"></a>
Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><b>m_F_uv</b></td></tr>
<tr class="separator:a7d3cff4413459b99f86db490df4c0e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbfd6ea9b75295f9528144c8e4cc094"><td class="memItemLeft" align="right" valign="top"><a id="a9fbfd6ea9b75295f9528144c8e4cc094" name="a9fbfd6ea9b75295f9528144c8e4cc094"></a>
std::vector&lt; <a class="el" href="struct_vertex_manifold_chart.html">VertexManifoldChart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_vertex_charts</b></td></tr>
<tr class="separator:a9fbfd6ea9b75295f9528144c8e4cc094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b867c51bbcde70c055cd27616beac3"><td class="memItemLeft" align="right" valign="top"><a id="ae9b867c51bbcde70c055cd27616beac3" name="ae9b867c51bbcde70c055cd27616beac3"></a>
std::vector&lt; <a class="el" href="struct_edge_manifold_chart.html">EdgeManifoldChart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_edge_charts</b></td></tr>
<tr class="separator:ae9b867c51bbcde70c055cd27616beac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ec828c619888177c762beb68006a9"><td class="memItemLeft" align="right" valign="top"><a id="a842ec828c619888177c762beb68006a9" name="a842ec828c619888177c762beb68006a9"></a>
std::vector&lt; <a class="el" href="struct_face_manifold_chart.html">FaceManifoldChart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_face_charts</b></td></tr>
<tr class="separator:a842ec828c619888177c762beb68006a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representation for an affine manifold, which is a topological manifold F equipped with a discrete metric l that satisfies the triangle inequality. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd024b85a5f3843f7e8c2552ffd2542b" name="abd024b85a5f3843f7e8c2552ffd2542b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd024b85a5f3843f7e8c2552ffd2542b">&#9670;&#160;</a></span>AffineManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineManifold::AffineManifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>global_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F_uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a cone manifold from a global parametrization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>faces of the cone manifold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_uv</td><td>global layout of the manifold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_uv</td><td>faces of the global layout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e14fba7016671a956b874969b66c99e" name="a6e14fba7016671a956b874969b66c99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e14fba7016671a956b874969b66c99e">&#9670;&#160;</a></span>add_to_viewer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::add_to_viewer </td>
          <td>(</td>
          <td class="paramtype">const MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>color</em> = <code>GOLD_YELLOW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the cone manifold and its data to the polyscope viewer with name 'cone_manifold'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>color for the affine manifold in the viewer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d42ebbfc83dc4296c7c54c53ea616d" name="a22d42ebbfc83dc4296c7c54c53ea616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d42ebbfc83dc4296c7c54c53ea616d">&#9670;&#160;</a></span>compute_boundary_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::compute_boundary_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_vertices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get list of all boundary vertices in the manifold</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">boundary_vertices</td><td>list of boundary vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad66b5b8fa55de132b00760a35cc16c79" name="ad66b5b8fa55de132b00760a35cc16c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66b5b8fa55de132b00760a35cc16c79">&#9670;&#160;</a></span>compute_cone_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::compute_cone_points </td>
          <td>(</td>
          <td class="paramtype">const MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>cone_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a matrix of cone point positions from mesh vertex positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cone_points</td><td>cone positions w.r.t. V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01a8524558ba2f7b8b233f5ff87e465" name="ad01a8524558ba2f7b8b233f5ff87e465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a8524558ba2f7b8b233f5ff87e465">&#9670;&#160;</a></span>compute_cones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::compute_cones </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>cones</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get list of all cones in the manifold</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cones</td><td>list of cone vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b4cadb93a95d30bc9d5b41dd6a1a36" name="ad4b4cadb93a95d30bc9d5b41dd6a1a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b4cadb93a95d30bc9d5b41dd6a1a36">&#9670;&#160;</a></span>compute_cones_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::compute_cones_corners </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::array&lt; bool, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_cone_corner</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get boolean mask of all cones corners in the manifold</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">is_cone_corner</td><td>true iff corner i, j is a cone </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf2ab050df58c8d1c05a5177b508686e" name="abf2ab050df58c8d1c05a5177b508686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2ab050df58c8d1c05a5177b508686e">&#9670;&#160;</a></span>compute_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AffineManifold::compute_curvature </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the curvature curvature at the given vertex.</p>
<p>Gaussian curvature is used for interior vertices and geodesic curvature for boundary vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_index</td><td>index of the vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>curvature at the given vertex </dd></dl>

</div>
</div>
<a id="a3e940c1335c5e897474c6bd57173e730" name="a3e940c1335c5e897474c6bd57173e730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e940c1335c5e897474c6bd57173e730">&#9670;&#160;</a></span>compute_flat_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::compute_flat_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>flat_vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get list of all flat vertices in the manifold</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">flat_vertices</td><td>list of flat vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f64c24d613162ca0b1b6a6606da4f1" name="a89f64c24d613162ca0b1b6a6606da4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f64c24d613162ca0b1b6a6606da4f1">&#9670;&#160;</a></span>cut_cone_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::cut_cone_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cut edges adjacent to cones so that a planar layout is possible around them. </p>

</div>
</div>
<a id="a429d86f39f9e64ca7fea38031e8bcadb" name="a429d86f39f9e64ca7fea38031e8bcadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429d86f39f9e64ca7fea38031e8bcadb">&#9670;&#160;</a></span>generate_boundary_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; AffineManifold::Index &gt; AffineManifold::generate_boundary_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return list of all boundary vertices in the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>list of boundary vertices </dd></dl>

</div>
</div>
<a id="a3cfe8922a412d98788352cb03028b291" name="a3cfe8922a412d98788352cb03028b291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe8922a412d98788352cb03028b291">&#9670;&#160;</a></span>generate_cones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; AffineManifold::Index &gt; AffineManifold::generate_cones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return list of all cones in the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>list of cone vertices </dd></dl>

</div>
</div>
<a id="af68eb1ee1d21fa8bb47daaba467d22c6" name="af68eb1ee1d21fa8bb47daaba467d22c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68eb1ee1d21fa8bb47daaba467d22c6">&#9670;&#160;</a></span>get_edge_chart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge_manifold_chart.html">EdgeManifoldChart</a> const  &amp; AffineManifold::get_edge_chart </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>face_vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an isometric chart for the edge opposite the corner with the given face index and vertex index within the face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>index of a face containing the target edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_vertex_index</td><td>index of the corner opposite the edge in the face </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>chart for the given edge </dd></dl>

</div>
</div>
<a id="acc633c3366f190094bf1c07f92910650" name="acc633c3366f190094bf1c07f92910650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc633c3366f190094bf1c07f92910650">&#9670;&#160;</a></span>get_F_uv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi const  &amp; AffineManifold::get_F_uv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get faces for the manifold parametrization</p>
<dl class="section return"><dt>Returns</dt><dd>faces of the manifold layout </dd></dl>

</div>
</div>
<a id="a8a0287f9ba0f2ba7e9936ba740ccc579" name="a8a0287f9ba0f2ba7e9936ba740ccc579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0287f9ba0f2ba7e9936ba740ccc579">&#9670;&#160;</a></span>get_face_chart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_face_manifold_chart.html">FaceManifoldChart</a> const  &amp; AffineManifold::get_face_chart </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>face_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an isometric chart for the given face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>index of a face </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>chart for the given face </dd></dl>

</div>
</div>
<a id="a7087fa8c1768c2b4327b93505f0e33b8" name="a7087fa8c1768c2b4327b93505f0e33b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7087fa8c1768c2b4327b93505f0e33b8">&#9670;&#160;</a></span>get_face_corner_charts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::get_face_corner_charts </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Matrix2x2r, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner_uv_positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the portions of the isometric vertex charts corresponding to the corners of a given face.</p>
<p>In particular, for a face ijk, the local chart layouts are given for: [0] vertices j and k in the vertex chart for vertex i [1] vertices k and i in the vertex chart for vertex j [2] vertices i and j in the vertex chart for vertex k</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>index of the face for the chart segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corner_uv_positions</td><td>chart uv positions as enumerated above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61a1a1db94bbed7312fd2b6cfe07027b" name="a61a1a1db94bbed7312fd2b6cfe07027b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a1a1db94bbed7312fd2b6cfe07027b">&#9670;&#160;</a></span>get_face_edge_charts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::get_face_edge_charts </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Matrix3x2r, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_edge_uv_positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the portion of the edge charts contained in the interior of the given face.</p>
<p>In particular, for a face ijk, the local chart layouts are given for: [0] vertices j, k, i in the vertex chart for edge ij [1] vertices k, i, j in the vertex chart for edge jk [2] vertices i, j, k in the vertex chart for edge ki</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>index of the face for the charts </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">face_edge_uv_positions</td><td>uv positions contained in the given face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a179fbd7b9050cf20a8c5c78e2e87f94b" name="a179fbd7b9050cf20a8c5c78e2e87f94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179fbd7b9050cf20a8c5c78e2e87f94b">&#9670;&#160;</a></span>get_face_global_uv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::get_face_global_uv </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; PlanarPoint, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_uv_positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the uv coordinates of the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>index of the face for the chart </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">face_edge_uv_positions</td><td>global uv positions of the face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e3caa36616a55fec146dd2a6a245301" name="a6e3caa36616a55fec146dd2a6a245301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3caa36616a55fec146dd2a6a245301">&#9670;&#160;</a></span>get_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi const  &amp; AffineManifold::get_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get faces for the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>faces of the manifold </dd></dl>

</div>
</div>
<a id="a58c0b0bef9631b4473650bd3bfe33950" name="a58c0b0bef9631b4473650bd3bfe33950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c0b0bef9631b4473650bd3bfe33950">&#9670;&#160;</a></span>get_global_uv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXr const  &amp; AffineManifold::get_global_uv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get global uv coordinates</p>
<dl class="section return"><dt>Returns</dt><dd>global uv coordinates, or the empty matrix if they do not exist </dd></dl>

</div>
</div>
<a id="a4da611ea8a9c4c82347e403c8c889f1f" name="a4da611ea8a9c4c82347e403c8c889f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da611ea8a9c4c82347e403c8c889f1f">&#9670;&#160;</a></span>get_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halfedge.html">Halfedge</a> const  &amp; AffineManifold::get_halfedge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get halfedge for the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>halfedge of the manifold </dd></dl>

</div>
</div>
<a id="a4e36285e30374755c46dee3611b43b15" name="a4e36285e30374755c46dee3611b43b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e36285e30374755c46dee3611b43b15">&#9670;&#160;</a></span>get_he_to_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; Eigen::Index, Eigen::Index &gt; &gt; const  &amp; AffineManifold::get_he_to_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get halfedge to corner map for the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>halfedge to corner map of the manifold </dd></dl>

</div>
</div>
<a id="a634cb38fb80495675c392abbd82f27c7" name="a634cb38fb80495675c392abbd82f27c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634cb38fb80495675c392abbd82f27c7">&#9670;&#160;</a></span>get_vertex_chart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vertex_manifold_chart.html">VertexManifoldChart</a> const  &amp; AffineManifold::get_vertex_chart </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an isometric chart for the vertex with the given index.</p>
<p>Note that this will be a homeomorphism about the vertex if and only if the metric is flat there. However, any such chart may be made into a (nonisometric) homeomorphism about the vertex by composition with a suitable angle normalization map (r, theta) -&gt; (r, 2 * pi * theta / (2 * pi - K)), where K is the Gaussian curvature at the vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_index</td><td>index of the vertex for the chart </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>chart for the given vertex </dd></dl>

</div>
</div>
<a id="a356d226d3ecf36569fb68df02b568ace" name="a356d226d3ecf36569fb68df02b568ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356d226d3ecf36569fb68df02b568ace">&#9670;&#160;</a></span>is_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineManifold::is_boundary </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the vertex is on the boundary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_index</td><td>index of the vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the vertex is on the boundary </dd></dl>

</div>
</div>
<a id="ad954f76d53659be3361d2c3c2e5f8adc" name="ad954f76d53659be3361d2c3c2e5f8adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad954f76d53659be3361d2c3c2e5f8adc">&#9670;&#160;</a></span>is_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineManifold::is_flat </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the manifold is flat at the given vertex, i.e. has zero Gaussian curvature or is a boundary vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_index</td><td>index of the vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the manifold is flat at the vertex </dd></dl>

</div>
</div>
<a id="aeb6c977f357135897e2d431714fe70fc" name="aeb6c977f357135897e2d431714fe70fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6c977f357135897e2d431714fe70fc">&#9670;&#160;</a></span>mark_cone_adjacent_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::mark_cone_adjacent_face </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>face_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a face as adjacent to a cone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face_index</td><td>face to mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a04906aca9ee8f0b89c237f992a0dc3" name="a6a04906aca9ee8f0b89c237f992a0dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a04906aca9ee8f0b89c237f992a0dc3">&#9670;&#160;</a></span>mark_cone_adjacent_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::mark_cone_adjacent_vertex </td>
          <td>(</td>
          <td class="paramtype">AffineManifold::Index&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a vertex as adjacent to a cone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_index</td><td>vertex to mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5a24a432a95df21beddec821e39b16" name="ade5a24a432a95df21beddec821e39b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a24a432a95df21beddec821e39b16">&#9670;&#160;</a></span>num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineManifold::Index AffineManifold::num_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of faces in the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>number of faces in the manifold </dd></dl>

</div>
</div>
<a id="a1c91854336d95c217e3316b24dc3c6a8" name="a1c91854336d95c217e3316b24dc3c6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c91854336d95c217e3316b24dc3c6a8">&#9670;&#160;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineManifold::Index AffineManifold::num_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of vertices in the manifold</p>
<dl class="section return"><dt>Returns</dt><dd>number of vertices in the manifold </dd></dl>

</div>
</div>
<a id="a74fc2437460dcbc13c5d64fc67ec2212" name="a74fc2437460dcbc13c5d64fc67ec2212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fc2437460dcbc13c5d64fc67ec2212">&#9670;&#160;</a></span>screenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::screenshot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpatialVector&#160;</td>
          <td class="paramname"><em>camera_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpatialVector&#160;</td>
          <td class="paramname"><em>camera_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_orthographic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save an image of the cone manifold and its data to file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>file to save the screenshot to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">camera_position</td><td>camera position for the screenshot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">camera_target</td><td>camera target for the screenshot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_orthographic</td><td>use orthographic perspective if true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98136d633fd83c40fe11e4e430b9f360" name="a98136d633fd83c40fe11e4e430b9f360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98136d633fd83c40fe11e4e430b9f360">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineManifold::view </td>
          <td>(</td>
          <td class="paramtype">const MatrixXr &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>View the cone manifold and its data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>mesh vertex positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/<a class="el" href="affine__manifold_8h_source.html">affine_manifold.h</a></li>
<li>src/core/affine_manifold.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
