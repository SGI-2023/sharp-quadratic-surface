<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quadratic Contours: src/contour_network/intersection_heuristics.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Quadratic Contours
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_91de53cc73c33c9d2ea5e599636de179.html">contour_network</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">intersection_heuristics.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;rational_function.h&quot;</code><br />
<code>#include &lt;chrono&gt;</code><br />
</div>
<p><a href="intersection__heuristics_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_intersection_stats.html">IntersectionStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abbc69e99c7c00449eb55b96026b0e233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#abbc69e99c7c00449eb55b96026b0e233">compute_homogeneous_bezier_points_over_interval</a> (const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;planar_curve, double t_min, double t_max, Eigen::Matrix&lt; double, 5, 3 &gt; &amp;bezier_points)</td></tr>
<tr class="memdesc:abbc69e99c7c00449eb55b96026b0e233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bezier control points for a curve over a domain.  <br /></td></tr>
<tr class="separator:abbc69e99c7c00449eb55b96026b0e233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d96a38b13619c1f91cf3daa7f299a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#a90d96a38b13619c1f91cf3daa7f299a9">compute_bezier_bounding_box</a> (const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;planar_curve, PlanarPoint &amp;lower_left_point, PlanarPoint &amp;upper_right_point)</td></tr>
<tr class="memdesc:a90d96a38b13619c1f91cf3daa7f299a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bounding box for a planar curve using Bezier control points for the two subcurves split at the middle.  <br /></td></tr>
<tr class="separator:a90d96a38b13619c1f91cf3daa7f299a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab591735ff869fac76231c817aa8f3cec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#ab591735ff869fac76231c817aa8f3cec">compute_bezier_bounding_boxes</a> (const std::vector&lt; <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &gt; &amp;planar_curves, std::vector&lt; PlanarPoint &gt; &amp;lower_left_points, std::vector&lt; PlanarPoint &gt; &amp;upper_right_points)</td></tr>
<tr class="memdesc:ab591735ff869fac76231c817aa8f3cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bounding boxes for a list of planar curve using Bezier control points.  <br /></td></tr>
<tr class="separator:ab591735ff869fac76231c817aa8f3cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696b69456fc7dd29a0cbb43ea8f05e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#a696b69456fc7dd29a0cbb43ea8f05e5a">combine_bounding_boxes</a> (const PlanarPoint &amp;first_box_lower_left_point, const PlanarPoint &amp;first_box_upper_right_point, const PlanarPoint &amp;second_box_lower_left_point, const PlanarPoint &amp;second_box_upper_right_point, PlanarPoint &amp;lower_left_point, PlanarPoint &amp;upper_right_point)</td></tr>
<tr class="memdesc:a696b69456fc7dd29a0cbb43ea8f05e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounding box containing two bounding boxes.  <br /></td></tr>
<tr class="separator:a696b69456fc7dd29a0cbb43ea8f05e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24d6d52b40a11d1c82ca00150301e2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#ad24d6d52b40a11d1c82ca00150301e2b">is_in_bounding_box</a> (const PlanarPoint &amp;test_point, const PlanarPoint &amp;lower_left_point, const PlanarPoint &amp;upper_right_point)</td></tr>
<tr class="memdesc:ad24d6d52b40a11d1c82ca00150301e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a test point is in a bounding box with extreme corners lower left point and upper right point.  <br /></td></tr>
<tr class="separator:ad24d6d52b40a11d1c82ca00150301e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d621e14dd69e6834f4658b67d37ba7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#ae0d621e14dd69e6834f4658b67d37ba7">are_nonintersecting_by_heuristic</a> (const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;first_planar_curve, const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;second_planar_curve, <a class="el" href="struct_intersection_stats.html">IntersectionStats</a> &amp;intersection_stats)</td></tr>
<tr class="memdesc:ae0d621e14dd69e6834f4658b67d37ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two planar curves cannot intersect by heuristics.  <br /></td></tr>
<tr class="separator:ae0d621e14dd69e6834f4658b67d37ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cbc40622d6df770fa972d1ad04b6ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#ac3cbc40622d6df770fa972d1ad04b6ba">are_nonintersecting_by_heuristic</a> (const std::pair&lt; PlanarPoint, PlanarPoint &gt; &amp;first_bounding_box, const std::pair&lt; PlanarPoint, PlanarPoint &gt; &amp;second_bounding_box, <a class="el" href="struct_intersection_stats.html">IntersectionStats</a> &amp;intersection_stats)</td></tr>
<tr class="memdesc:ac3cbc40622d6df770fa972d1ad04b6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two planar curves cannot intersect by heuristics using just the bounding boxes of the curve.  <br /></td></tr>
<tr class="separator:ac3cbc40622d6df770fa972d1ad04b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b7d7ef96495d43575feea748443b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#a19b7d7ef96495d43575feea748443b72">compute_bounding_box_hash_table</a> (const std::vector&lt; std::pair&lt; PlanarPoint, PlanarPoint &gt; &gt; &amp;bounding_boxes, std::vector&lt; int &gt; hash_table[50][50], std::vector&lt; std::vector&lt; int &gt; &gt; &amp;reverse_hash_table)</td></tr>
<tr class="memdesc:a19b7d7ef96495d43575feea748443b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash bounding boxes by x and y coordinates.  <br /></td></tr>
<tr class="separator:a19b7d7ef96495d43575feea748443b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14cde502618479497423e384905f08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intersection__heuristics_8h.html#ab14cde502618479497423e384905f08e">has_linear_intersection</a> (const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;first_planar_curve, const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;second_planar_curve)</td></tr>
<tr class="memdesc:ab14cde502618479497423e384905f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the line between the endpoints of two curves intersect.  <br /></td></tr>
<tr class="separator:ab14cde502618479497423e384905f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Methods to quickly determine if two planar curves do not intersect. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae0d621e14dd69e6834f4658b67d37ba7" name="ae0d621e14dd69e6834f4658b67d37ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d621e14dd69e6834f4658b67d37ba7">&#9670;&#160;</a></span>are_nonintersecting_by_heuristic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool are_nonintersecting_by_heuristic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_planar_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_planar_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_intersection_stats.html">IntersectionStats</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two planar curves cannot intersect by heuristics. </p>
<p>This method can only determine if two curves do not intersect and may have false negatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_planar_curve</td><td>first planar curve segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_planar_curve</td><td>second planar curve segment </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">intersection_stats</td><td>statistics for intersections computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two curves do not intersect </dd></dl>

</div>
</div>
<a id="ac3cbc40622d6df770fa972d1ad04b6ba" name="ac3cbc40622d6df770fa972d1ad04b6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cbc40622d6df770fa972d1ad04b6ba">&#9670;&#160;</a></span>are_nonintersecting_by_heuristic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool are_nonintersecting_by_heuristic </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; PlanarPoint, PlanarPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_bounding_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; PlanarPoint, PlanarPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_bounding_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_intersection_stats.html">IntersectionStats</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two planar curves cannot intersect by heuristics using just the bounding boxes of the curve. </p>
<p>This method can only determine if two curves do not intersect and may have false negatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_bounding_box</td><td>bounding box of the first planar curve segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_bounding_box</td><td>bounding box of the second planar curve segment </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">intersection_stats</td><td>statistics for intersections computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two curves do not intersect </dd></dl>

</div>
</div>
<a id="a696b69456fc7dd29a0cbb43ea8f05e5a" name="a696b69456fc7dd29a0cbb43ea8f05e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696b69456fc7dd29a0cbb43ea8f05e5a">&#9670;&#160;</a></span>combine_bounding_boxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void combine_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>first_box_lower_left_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>first_box_upper_right_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>second_box_lower_left_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>second_box_upper_right_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>lower_left_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>upper_right_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bounding box containing two bounding boxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_box_lower_left_point</td><td>lower left point of the first bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_box_upper_right_point</td><td>upper right point of the first bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_box_lower_left_point</td><td>lower left point of the second bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_box_upper_right_point</td><td>upper right point of the second bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_left_point</td><td>lower left point of the combined bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_right_point</td><td>upper right point of the combined bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90d96a38b13619c1f91cf3daa7f299a9" name="a90d96a38b13619c1f91cf3daa7f299a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d96a38b13619c1f91cf3daa7f299a9">&#9670;&#160;</a></span>compute_bezier_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_bezier_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>planar_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>lower_left_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>upper_right_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bounding box for a planar curve using Bezier control points for the two subcurves split at the middle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planar_curve</td><td>planar curve segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_left_point</td><td>lower left point of the bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_right_point</td><td>upper right point of the bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab591735ff869fac76231c817aa8f3cec" name="ab591735ff869fac76231c817aa8f3cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab591735ff869fac76231c817aa8f3cec">&#9670;&#160;</a></span>compute_bezier_bounding_boxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_bezier_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>planar_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PlanarPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_left_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PlanarPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_right_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bounding boxes for a list of planar curve using Bezier control points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planar_curves</td><td>planar curve segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_left_points</td><td>lower left points of the bounding boxes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_right_points</td><td>upper right points of the bounding boxes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19b7d7ef96495d43575feea748443b72" name="a19b7d7ef96495d43575feea748443b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b7d7ef96495d43575feea748443b72">&#9670;&#160;</a></span>compute_bounding_box_hash_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_bounding_box_hash_table </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; PlanarPoint, PlanarPoint &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounding_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>hash_table</em>[50][50], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse_hash_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash bounding boxes by x and y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bounding_boxes</td><td>bounding boxes to hash </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hash_table</td><td>lists of bounding boxes per hash region </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reverse_hash_table</td><td>map from bounding boxes to ids of hash regions containing them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbc69e99c7c00449eb55b96026b0e233" name="abbc69e99c7c00449eb55b96026b0e233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc69e99c7c00449eb55b96026b0e233">&#9670;&#160;</a></span>compute_homogeneous_bezier_points_over_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_homogeneous_bezier_points_over_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>planar_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 5, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bezier_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bezier control points for a curve over a domain. </p>
<p>The domain may differ from the domain of the planar curve itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planar_curve</td><td>planar curve segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_min</td><td>lower bound of the domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_max</td><td>upper bound of the domain </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bezier_points</td><td>homogeneous control points of the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab14cde502618479497423e384905f08e" name="ab14cde502618479497423e384905f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14cde502618479497423e384905f08e">&#9670;&#160;</a></span>has_linear_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool has_linear_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_planar_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rational_function.html">RationalFunction</a>&lt; 4, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_planar_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the line between the endpoints of two curves intersect. </p>
<p>Note that linear intersection does not imply curve intersection, and the the absence of linear intersection does not imply the curves do not intersect. It just roughly indicates potential intersections for simple curves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_planar_curve</td><td>first planar curve segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_planar_curve</td><td>second planar curve segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the lines between the respective endpoints of the curves intersect </dd></dl>

</div>
</div>
<a id="ad24d6d52b40a11d1c82ca00150301e2b" name="ad24d6d52b40a11d1c82ca00150301e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24d6d52b40a11d1c82ca00150301e2b">&#9670;&#160;</a></span>is_in_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_in_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>test_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>lower_left_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlanarPoint &amp;&#160;</td>
          <td class="paramname"><em>upper_right_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a test point is in a bounding box with extreme corners lower left point and upper right point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">test_point</td><td>point to test for containment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_left_point</td><td>lower left point of the bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_right_point</td><td>upper right point of the bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the test point is in the bounding box </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
